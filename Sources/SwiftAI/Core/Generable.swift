import Foundation

/// A type that can be generated by language models.
///
/// Annotate your model types with the `@Generable` macro to allow the model to respond
/// to prompts by generating an instance of your type. Use the `@Guide` macro to provide
/// natural language descriptions of your properties, and programmatically control
/// the values that the model can generate.
///
/// ## Example
///
/// ```swift
/// @Generable
/// struct WeatherReport {
///   @Guide("The current temperature in Celsius")
///   let temperature: Int
///
///   @Guide("Brief description of current conditions")
///   let conditions: String
///
///   @Guide("Chance of precipitation as percentage", .range(0...100))
///   let precipitationChance: Int
/// }
///
/// // Use with an LLM
/// let report = try await llm.reply(
///   to: [UserMessage(chunks: [.text("What's the weather in Paris?")])],
///   returning: WeatherReport.self
/// )
/// ```
public protocol Generable: Codable, Sendable {
  /// The schema that describes the structure and constraints of this type.
  static var schema: Schema { get }
}

// MARK: - Macro Declaration

/// Conforms types to Generable by automatically generating schema implementations.
///
/// This macro analyzes your struct or class and generates the required `schema` property
/// that describes the structure for language model generation.
///
/// ## Example
///
/// ```swift
/// @Generable
/// struct Recipe {
///   let name: String
///   let ingredients: [String]
///   let cookingTime: Int
/// }
/// ```
@attached(extension, conformances: Generable, names: named(schema))
public macro Generable(description: String? = nil) =
  #externalMacro(module: "SwiftAIMacros", type: "GenerableMacro")

// MARK: - Basic Type Conformances

/// String conforms to Generable for simple text generation use cases.
extension String: Generable {
  public static var schema: Schema {
    .string(constraints: [], metadata: nil)
  }
}
