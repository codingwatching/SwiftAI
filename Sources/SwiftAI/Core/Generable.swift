import Foundation

/// A type that can be generated by language models.
///
/// Annotate your model types with the `@Generable` macro to allow the model to respond
/// to prompts by generating an instance of your type. Use the `@Guide` macro to provide
/// natural language descriptions of your properties, and programmatically control
/// the values that the model can generate.
///
/// ## Example
///
/// ```swift
/// @Generable
/// struct WeatherReport {
///   @Guide("The current temperature in Celsius")
///   let temperature: Int
///
///   @Guide("Brief description of current conditions")
///   let conditions: String
///
///   @Guide("Chance of precipitation as percentage", .range(0...100))
///   let precipitationChance: Int
/// }
///
/// // Use with an LLM
/// let report = try await llm.reply(
///   to: [UserMessage(chunks: [.text("What's the weather in Paris?")])],
///   returning: WeatherReport.self
/// )
/// ```
public protocol Generable: Codable, Sendable {
  /// The schema that describes the structure and constraints of this type.
  static var schema: Schema { get }

  /// The structured representation of this generable instance.
  var generableContent: StructuredContent { get }
}

// MARK: - Macro Declaration

/// Conforms types to Generable by automatically generating schema implementations.
///
/// This macro analyzes your struct or class and generates the required `schema` property
/// that describes the structure for language model generation.
///
/// ## Example
///
/// ```swift
/// @Generable
/// struct Recipe {
///   let name: String
///   let ingredients: [String]
///   let cookingTime: Int
/// }
/// ```
@attached(extension, conformances: Generable, names: named(schema), named(generableContent))
public macro Generable(description: String? = nil) =
  #externalMacro(module: "SwiftAIMacros", type: "GenerableMacro")

/// Provides generation guidance for properties in Generable types.
///
/// Use this macro to add natural language descriptions and constraints to properties
/// that will be generated by language models. The `@Guide` macro enhances the
/// schema generation process by providing semantic context and constraints.
///
/// ## Simple Description
///
/// ```swift
/// @Generable
/// struct User {
///   @Guide(description: "The user's full name")
///   let name: String
///
///   @Guide(description: "User's age in years")
///   let age: Int
/// }
/// ```
///
/// ## With Constraints
///
/// ```swift
/// @Generable
/// struct Product {
///   @Guide(description: "Product identifier", .pattern("[A-Z]{3}-\\d{4}"))
///   let sku: String
///
///   @Guide(description: "Price in USD", .range(0.01...9999.99))
///   let price: Double
///
///   @Guide(description: "Quantity in stock", .minimum(0))
///   let quantity: Int
/// }
/// ```
@attached(peer)
public macro Guide(description: String) =
  #externalMacro(module: "SwiftAIMacros", type: "GuideMacro")

@attached(peer)
public macro Guide<T>(description: String? = nil, _ constraints: Constraint<T>...) =
  #externalMacro(module: "SwiftAIMacros", type: "GuideMacro")

// MARK: - Basic Type Conformances

/// String conforms to Generable for simple text generation use cases.
extension String: Generable {
  public static var schema: Schema {
    .string(constraints: [])
  }

  public var generableContent: StructuredContent {
    StructuredContent(kind: .string(self))
  }
}

/// Int conforms to Generable for integer generation use cases.
extension Int: Generable {
  public static var schema: Schema {
    .integer(constraints: [])
  }

  public var generableContent: StructuredContent {
    StructuredContent(kind: .integer(self))
  }
}

/// Double conforms to Generable for floating-point number generation use cases.
extension Double: Generable {
  public static var schema: Schema {
    .number(constraints: [])
  }

  public var generableContent: StructuredContent {
    StructuredContent(kind: .number(self))
  }
}

/// Bool conforms to Generable for boolean generation use cases.
extension Bool: Generable {
  public static var schema: Schema {
    .boolean(constraints: [])
  }

  public var generableContent: StructuredContent {
    StructuredContent(kind: .bool(self))
  }
}

/// Array conforms to Generable when its elements conform to Generable.
extension Array: Generable where Element: Generable {
  public static var schema: Schema {
    .array(items: Element.schema, constraints: [])
  }

  public var generableContent: StructuredContent {
    StructuredContent(kind: .array(self.map { $0.generableContent }))
  }
}
