import Foundation

/// Unit of information exchanged during a conversation between a user and a language model.
///
/// Messages form the building blocks of conversations, where each message has a specific role
/// (system, user, ai, etc.) and a payload.
///
/// ## Usage Example
///
/// ```swift
/// let conversation: [Message] = [
///   .system(.init(text: "You are a helpful assistant.")),
///   .user(.init(text: "What's the weather today?")),
///   .ai(.init(text: "The weather is sunny and 25Â°C."))
/// ]
/// ```
public enum Message: PromptRepresentable, Equatable, Sendable, Identifiable {
  case system(SystemMessage)
  case user(UserMessage)
  case ai(AIMessage)
  case toolOutput(ToolOutput)

  public var role: Role {
    switch self {
    case .system: .system
    case .user: .user
    case .ai: .ai
    case .toolOutput: .toolOutput
    }
  }

  public var id: String {
    switch self {
    case .system(let message): message.id
    case .user(let message): message.id
    case .ai(let message): message.id
    case .toolOutput(let message): message.id
    }
  }

  public var chunks: [ContentChunk] {
    switch self {
    case .system(let message): message.chunks
    case .user(let message): message.chunks
    case .ai(let message): message.chunks
    case .toolOutput(let message): message.chunks
    }
  }

  /// Specifies instructions for the AI's behavior and constraints.
  /// LLMs follow these instructions more carefully than other messages.
  public struct SystemMessage: PromptRepresentable, Equatable, Sendable {
    public let id = UUID().uuidString

    public let chunks: [ContentChunk]

    public init(chunks: [ContentChunk]) {
      self.chunks = chunks
    }

    public init(text: String) {
      self.chunks = [.text(text)]
    }

    // TODO: Add inits that take a Prompt and/or PromptBuilder.
  }

  /// A message sent by a user to the LLM.
  public struct UserMessage: PromptRepresentable, Equatable, Sendable, Identifiable {
    public let id = UUID().uuidString

    public let chunks: [ContentChunk]

    public init(chunks: [ContentChunk]) {
      self.chunks = chunks
    }

    public init(text: String) {
      self.chunks = [.text(text)]
    }

    // TODO: Add inits that take a Prompt and/or PromptBuilder.
  }

  /// A message generated by the AI assistant.
  public struct AIMessage: PromptRepresentable, Equatable, Sendable, Identifiable {
    public let id = UUID().uuidString

    public let chunks: [ContentChunk]
    public let toolCalls: [ToolCall]

    public init(chunks: [ContentChunk], toolCalls: [ToolCall]) {
      self.chunks = chunks
      self.toolCalls = toolCalls
    }

    public init(text: String) {
      self.chunks = [.text(text)]
      self.toolCalls = []
    }

    // TODO: Add inits that take a Prompt and/or PromptBuilder.
  }

  /// A message containing the output from a tool execution.
  public struct ToolOutput: PromptRepresentable, Equatable, Sendable, Identifiable {
    /// ID for matching tool calls to outputs.
    public let id: String

    /// The name of the tool that was executed.
    public let toolName: String

    /// The output content from the tool execution.
    public let chunks: [ContentChunk]

    public init(id: String, toolName: String, chunks: [ContentChunk]) {
      self.id = id
      self.toolName = toolName
      self.chunks = chunks
      // TODO: Throw if the toolName is empty.
    }
  }

  /// Represents a request to execute a specific tool with arguments.
  public struct ToolCall: Sendable, Equatable, Identifiable {
    /// Identifier used to reference the tool call and its results in the conversation.
    public let id: String

    /// The name of the tool to execute.
    public let toolName: String

    /// The arguments to pass to the tool as structured content.
    public let arguments: StructuredContent

    public init(id: String, toolName: String, arguments: StructuredContent) {
      self.id = id
      self.toolName = toolName
      self.arguments = arguments
      // TODO: Throw if the toolName is empty.
    }
  }
}

// TODO: Consider remcving the Role enum.
/// Defines the sender's role in a conversation between users and language models.
///
/// Roles establish the context and expected behavior for each message in a conversation,
/// enabling proper message attribution and conversation flow management.
public enum Role: Sendable, Equatable {
  /// System-level instructions that define the AI's behavior and constraints.
  /// The LLM follows these instructions more carefully than other messages.
  case system

  /// The entity who interacts with the AI assistant (e.g., a human user).
  case user

  /// Messages generated by the AI assistant.
  case ai

  /// Results returned from tool execution.
  case toolOutput
}

/// A fragment of data within a message.
///
/// Message can be made of multiple chunks, allowing for complex interactions.
///
/// Content chunks allow messages to contain multi-modal data while maintaining
/// type safety. This enables rich conversations that can include plain text alongside
/// structured data and tool interactions for example.
public enum ContentChunk: Sendable, Equatable {
  /// Plain text content.
  case text(String)

  /// Structured data.
  case structured(StructuredContent)
}
