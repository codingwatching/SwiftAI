import Foundation

/// Defines the structure and constraints of types to generate.
///
/// A schema describes the expected format of data that can be generated by language models,
/// including type information, validation constraints, and metadata to guide generation.
public enum Schema: Sendable, Equatable {
  // TODO: Consider adding a type parameter.
  //   We can make certain operations type safe by adding a type parameter to the schema.
  //   For example, we can make `withConstraint` safe.
  //   This would disallow writing `schema.withConstraint(.pattern("abc"))` when the schema
  //   represents an integer, for example.

  /// An object with defined properties.
  case object(name: String, description: String?, properties: [String: Property])

  /// A union type that can match any of the provided schemas.
  indirect case anyOf(name: String, description: String?, schemas: [Schema])

  /// An array containing items of a specific schema.
  indirect case array(items: Schema, constraints: [ArrayConstraint])

  /// A string value with optional constraints.
  case string(constraints: [StringConstraint])

  /// An integer value with optional constraints.
  case integer(constraints: [IntConstraint])

  /// A floating-point number with optional constraints.
  case number(constraints: [DoubleConstraint])

  /// A boolean value with optional constraints.
  case boolean(constraints: [BoolConstraint])

  // TODO: Add support to object references and recursive schemas.

  /// Returns a new schema with the given constraint.
  ///
  /// The method attempts to apply the constraint to the schema. If the constraint is not
  /// compatible with the schema structure, the constraint is no-op.
  ///
  /// - Parameter constraint: The constraint to add.
  /// - Returns: A new schema with the constraint added.
  public func withConstraint<Value>(_ constraint: Constraint<Value>) -> Schema {
    withConstraint(AnyConstraint(constraint))
  }

  /// Returns a new schema with the given constraints.
  ///
  /// The method attempts to apply the constraints to the schema. If one of the constraints is
  /// not compatible with the schema structure, that constraint is no-op and the others are applied.
  ///
  /// - Parameter constraints: The constraints to add.
  /// - Returns: A new schema with constraints added.
  public func withConstraints<Value>(_ constraints: [Constraint<Value>]) -> Schema {
    withConstraints(constraints.map(AnyConstraint.init))
  }

  func withConstraint(_ constraint: AnyConstraint) -> Schema {
    switch (self, constraint.payload) {
    case (.array(let items, let constraints), .sub(let subConstraint)):
      return .array(items: items.withConstraint(subConstraint), constraints: constraints)

    case (_, .this(let kind)):
      // Handle direct constraints
      switch (self, kind) {
      case (.string(let constraints), .string(let newConstraint)):
        return .string(constraints: constraints + [newConstraint])

      case (.integer(let constraints), .int(let newConstraint)):
        return .integer(constraints: constraints + [newConstraint])

      case (.number(let constraints), .double(let newConstraint)):
        return .number(constraints: constraints + [newConstraint])

      case (.boolean(let constraints), .boolean):
        return .boolean(constraints: constraints)

      case (.array(let items, let constraints), .array(let arrayConstraint)):
        return .array(items: items, constraints: constraints + [arrayConstraint])

      default:
        // TODO: This assertion should only be enabled in debug + strict mode.
        assertionFailure("Invalid constraint \(kind) for schema \(self)")
        return self
      }

    default:
      // TODO: This assertion should only be enabled in debug + strict mode.
      assertionFailure("Invalid constraint \(constraint.payload) for schema \(self)")
      return self
    }
  }

  func withConstraints(_ constraints: [AnyConstraint]) -> Schema {
    constraints.reduce(self) { schema, constraint in
      schema.withConstraint(constraint)
    }
  }

  /// Represents a property within an object schema.
  public struct Property: Sendable, Equatable {
    /// The schema that defines this property's structure.
    public let schema: Schema

    /// Provides context for this property within the parent object.
    public let description: String?

    /// Whether this property is optional in the parent object.
    public let isOptional: Bool

    /// Creates a new property with the specified schema and optionality.
    ///
    /// - Parameters:
    ///   - schema: The schema that defines this property's structure
    ///   - description: Optional description for this property
    ///   - isOptional: Whether this property is optional in the parent object
    public init(schema: Schema, description: String?, isOptional: Bool) {
      self.schema = schema
      self.description = description
      self.isOptional = isOptional
    }
  }
}
